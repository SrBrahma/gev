import execa from 'execa';
import { flavorsArray } from '../src/typesAndConsts';
import Path from 'path';
import fse from 'fs-extra';
import ora from 'ora';
import globby from 'globby'

/** Will build, to use the dist code */
export async function generateTemplates(): Promise<void> {

  const templatesPath = Path.join(__dirname, '..', 'templates');
  const templatesReadmePath = Path.join(templatesPath, 'README.md');

  // Build the project, so we will run like the users will do (they won't run the .ts)
  await ora.promise(async () => {
    await fse.emptyDir(templatesPath);
    await fse.writeFile(templatesReadmePath, readmeContent);
    await execa('npm', ['run', 'build'], { cwd: Path.join(__dirname, '..') });
  }, 'Building project before generating templates');

    // Run from dist each flavor
  for (const flavor of flavorsArray) {
    await ora.promise(async () => {
      await execa('node', ['..', '--no-install', flavor, flavor], { cwd: templatesPath });
      // Remove possible ".git" in the generated template. It would mess pushing it to git and GitHub.
      const gitPaths = await globby('**/.git', {
        onlyFiles: false, cwd: Path.join(templatesPath, flavor), absolute: true
      })
      for (const gitPath of gitPaths)
        await fse.remove(gitPath)
    }, `Generating template "${flavor}"`)
  }
}


generateTemplates().catch(err => {
  let msg;
  if (typeof err === 'object' && err !== null)
    msg = err.message;
  else
    msg = err;
  console.error('Error generating templates:');
  console.error(msg);
  process.exit(1);
});

const readmeContent = `# Those templates were generated by an automated use of **\`gev\`**,

## so you can see the actual result of each flavor boilerplate.

<br/>

### While you may use those templates directly, it's recommended to generate the desired flavor by the use of the \`gev\` command, so the latest packages are installed and the configurations related to you and your project are used.

<br/>

## Generated at: **${new Date().toUTCString()}**
`